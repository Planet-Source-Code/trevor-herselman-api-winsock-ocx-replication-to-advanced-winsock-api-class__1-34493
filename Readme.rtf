{\rtf1\ansi\ansicpg1252\uc1\deff0\stshfdbch0\stshfloch0\stshfhich0\stshfbi0\deflang7177\deflangfe7177{\fonttbl{\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}{\f36\froman\fcharset238\fprq2 Times New Roman CE;}{\f37\froman\fcharset204\fprq2 Times New Roman Cyr;}{\f39\froman\fcharset161\fprq2 Times New Roman Greek;}
{\f40\froman\fcharset162\fprq2 Times New Roman Tur;}{\f41\froman\fcharset177\fprq2 Times New Roman (Hebrew);}{\f42\froman\fcharset178\fprq2 Times New Roman (Arabic);}{\f43\froman\fcharset186\fprq2 Times New Roman Baltic;}
{\f44\froman\fcharset163\fprq2 Times New Roman (Vietnamese);}{\f46\fswiss\fcharset238\fprq2 Arial CE;}{\f47\fswiss\fcharset204\fprq2 Arial Cyr;}{\f49\fswiss\fcharset161\fprq2 Arial Greek;}{\f50\fswiss\fcharset162\fprq2 Arial Tur;}
{\f51\fswiss\fcharset177\fprq2 Arial (Hebrew);}{\f52\fswiss\fcharset178\fprq2 Arial (Arabic);}{\f53\fswiss\fcharset186\fprq2 Arial Baltic;}{\f54\fswiss\fcharset163\fprq2 Arial (Vietnamese);}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;
\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;
\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang7177\langfe7177\cgrid\langnp7177\langfenp7177 \snext0 Normal;}{\*\cs10 \additive 
\ssemihidden Default Paragraph Font;}{\*\ts11\tsrowd\trftsWidthB3\trpaddl108\trpaddr108\trpaddfl3\trpaddft3\trpaddfb3\trpaddfr3\trcbpat1\trcfpat1\tscellwidthfts0\tsvertalt\tsbrdrt\tsbrdrl\tsbrdrb\tsbrdrr\tsbrdrdgl\tsbrdrdgr\tsbrdrh\tsbrdrv 
\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1024\langfe1024\cgrid\langnp1024\langfenp1024 \snext11 \ssemihidden Normal Table;}}{\*\listtable{\list\listtemplateid-1345294762\listsimple{\listlevel\levelnfc23
\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat0\levelspace0\levelindent0{\leveltext\'01*;}{\levelnumbers;}}{\listname ;}\listid-2}}{\*\listoverridetable{\listoverride\listid-2\listoverridecount1{\lfolevel\listoverrideformat{\listlevel
\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat0\levelold\levelspace0\levelindent0{\leveltext\'01\u-3913 ?;}{\levelnumbers;}\f3\fbias0 }}\ls1}}{\*\rsidtbl \rsid5975617\rsid7025986\rsid8735674\rsid15615675}
{\*\generator Microsoft Word 10.0.3416;}{\info{\author THerselman}{\operator THerselman}{\creatim\yr2002\mo5\dy15\hr12\min3}{\revtim\yr2002\mo5\dy16\hr23\min36}{\version4}{\edmins26}{\nofpages10}{\nofwords3913}{\nofchars22310}
{\*\company Draught Dispense Services}{\nofcharsws26171}{\vern16453}}\widowctrl\ftnbj\aenddoc\noxlattoyen\expshrtn\noultrlspc\dntblnsbdb\nospaceforul\hyphcaps0\horzdoc\dghspace120\dgvspace120\dghorigin1701\dgvorigin1984\dghshow0\dgvshow3
\jcompress\viewkind4\viewscale100\nolnhtadjtbl\rsidroot8735674 \fet0\sectd \linex0\sectdefaultcl\sftnbj {\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang {\pntxta .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang {\pntxta .}}{\*\pnseclvl3
\pndec\pnstart1\pnindent720\pnhang {\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang {\pntxta )}}{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}
{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}{\*\pnseclvl8\pnlcltr\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}\pard\plain 
\ql \li0\ri0\nowidctlpar\faauto\rin0\lin0\itap0 \fs24\lang7177\langfe7177\cgrid\langnp7177\langfenp7177 {\b\f1\ul\insrsid8735674 INCOMPLETE!
\par 
\par Getting Started}{\f1\fs20\insrsid8735674 
\par 
\par }{\b\f1\fs20\ul\insrsid8735674 In the begining ...}{\f1\fs20\insrsid8735674 
\par 
\par This project started as most of this nature, I didn't like the idea of using the OCX when the WinSock API was a more powerful route! I also didn't like all the talk about memory leaks in the OCX and couldn't bring myself to use a buggy control! So this hu
m
ble idea started as a project to religiously convert all the OCX commands to API commands (meaning I wanted an exact replica using the API). What happened? It CANNOT be done in pure VB even with API calls, the origional OCX was developed in C++. To give y
ou a simple example, everyone who has done this has had to change the name of the origional WinSock OCX 'Close' statement because it is a reserved word in VB. So we already have a difference. 
\par 
\par }{\b\f1\fs20\ul\insrsid8735674 What do I need to begin?}{\f1\fs20\insrsid8735674 
\par 
\par This project is designed to be as eas
y to implement as possible, into ANY and ALL VB projects requiring WinSock API functionality. Knowing the structure of the code will allow you to perfectly tune and customize it, but is not a requirement for general use. The Class module (clsSox) is the h
eart of the code, it's an essential for obvious reasons. The normal Module (modSox) is also necessary but is where most of your changes will be made. The form is only my dummy project so you can see Sox in action :)
\par 
\par }{\b\f1\ul\insrsid8735674 OCX Differences}{\f1\fs20\insrsid8735674 
\par 
\par }{\b\f1\fs20\ul\insrsid8735674 Purpose}{\f1\fs20\insrsid8735674 
\par 
\par For those familiar with the OCX, that would like to know what the equivalent commands are, which ones have fallen away and why, and what are the new features in Sox
\par 
\par }{\b\f1\fs20\insrsid8735674 OCX}{\f1\fs20\insrsid8735674 
\par 
\par Properties
\par 
\par BytesReceived - Returns the amount of data received (currently in the receive buffer). Use the GetData method to retrieve data.
\par Index - Returns or sets the number that uniquely identifies an object in a collection.
\par LocalHostName - Returns the local machine name. Read-only and unavailable at design time.
\par LocalIP - Returns the IP address of the local machine in the IP address dotted string format (xxx.xxx.xxx.xxx).Read-only and unavailable at design time.
\par LocalPort - Returns or sets the local port to use. Read/Write and available at design time. 
\par Name - Returns the name used in code to identify a form, control, or data access object. Read-only atrun time.
\par Object - Returns the object and/or a setting of an object's method or property.
\par Parent - Returns the form, object, or collection that contains a control or another object or collection.
\par Protocol - Returns or sets the protocol, either TCP or UDP, used by the Winsock control.
\par RemoteHost - Returns or sets the remote machine to which a control sends or receives data. You can either provide a host name, for example, "FTP://ftp.microsoft.com," or an IP address string in dotted format, such as "100.0.1.1".
\par RemoteHostIP - Returns the IP address of the remote machine. 
\par RemotePort - Returns or sets the remote port number to connect to.
\par SocketHandle - Returns a value that corresponds to the socket handle the control uses to communicate with the Winsock layer. Read-only and unavailable at design time.
\par State - Returns the state of the control, expressed as an enumerated type. Read-only and unavailable at design time.
\par Tag - Returns or sets an expression that stores any extra data needed for your program. Unlike other properties, the value of the Tag property isn't used by Visual Basic; you can use this property to identify objects.
\par 
\par Methods
\par 
\par Accept(requestID as Long) - For TCP server applications only. This method is used to accept an incoming connection when handling a ConnectionRequest event.
\par Bind([LocalPort],[LocalIP]) - Specifies the LocalPort and LocalIP to be used for TCP connections. Use this method if you have multiple protocol adapters.
\par Close - Closes a TCP connection or a listening socket for both client and server applications.
\par Connect([RemoteHost],[RemotePort]) - Requests a connection to a remote computer.
\par GetData(data,[type],[maxLen]) - Retrieves the current block of data and stores it in a variable of type variant.
\par Listen - Creates a socket and sets it in listen mode. This method works only for TCP connections.
\par PeekData(data,[type],[maxLen]) - Similar to GetData except PeekData does not remove data from the input queue. This method works only for TCP connections.
\par SendData (Data) - Sends data to a remote computer.
\par 
\par Events
\par 
\par Close() - Occurs when the remote computer closes the connection. Applications should use the Close method to correctly close a TCP connection.
\par Connect() - Occurs when a Connect operation is completed.
\par ConnectionRequest(ByVal requestID As Long) - Occurs when a remote machine requests a connection. 
\par DataArrival(ByVal bytesTotal As Long) - Occurs when new data arrives.
\par Error(ByVal Number As Integer, Description As String, ByVal Sco
de As Long, ByVal Source As String, ByVal HelpFile As String, ByVal HelpContext As Long, CancelDisplay As Boolean) - Occurs whenever an error occurs in background processing (for example, failed to connect, or failed to send or receive in the background).

\par SendComplete() - Occurs when a send operation is completed.
\par SendProgress(ByVal bytesSent As Long, ByVal bytesRemaining As Long) - Occurs while data is being sent.
\par 
\par Constants
\par 
\par sckTCPProtocol
\par sckUDPProtocol
\par 
\par }{\b\f1\ul\insrsid8735674 Sox Structure}{\f1\fs20\insrsid8735674 
\par 
\par }{\b\f1\fs20\ul\insrsid8735674 Purpose}{\f1\fs20\insrsid8735674 
\par 
\par To take an in-depth look at the structure of the Sox project. This will explain in detail EVERY function and procedure, it's purpose, uses and areas you may be interested in improving/customizing. The areas of improvement will most likely come from the re
moval of unwanted/unused features depending on your needs. The areas of customization will come in if your project has special requirements not being met by the foundation class.
\par 
\par }{\b\f1\fs20\ul\insrsid8735674 Conventions}{\f1\fs20\insrsid8735674 
\par 
\par All API call begin with prefix api, constants are in CAPS, Enums begin with sox. Types begin with typ. ALL my variables are 'encapsulated' into 3 types. WSAData, Portal and Sockets(). 
\par 
\par Private Sub Class_Initialize()
\par {\pntext\pard\plain\f3\fs20\insrsid8735674 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \ql \fi-720\li720\ri0\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3 {\pntxtb \'b7}}\faauto\ls1\rin0\lin720\itap0\pararsid8735674 {\f1\fs20\insrsid8735674 
apiWSAStartup is used to initialize your application with use 
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\rin0\lin0\itap0 {\f1\fs20\insrsid8735674 
\par 
\par 
\par Private Sub Class_Terminate()
\par 
\par 
\par 
\par 
\par 
\par }{\b\f1\ul\insrsid8735674 Feature Review}{\f1\fs20\insrsid8735674 
\par 
\par }{\b\f1\fs20\ul\insrsid8735674 Purpose}{\f1\fs20\insrsid8735674 
\par 
\par To show the advantages of using Sox in your code over the OCX or any other similar project.
\par 
\par 
\par }{\b\f1\ul\insrsid8735674 FAQ}{\f1\fs20\insrsid8735674 
\par 
\par 
\par 
\par 
\par }{\b\f1\ul\insrsid8735674 API}{\f1\fs20\insrsid8735674 
\par 
\par WSAStartup
\par 
\par Basics: Tells WinSock API that your app wants to use it, WinSock API creates a memory space internally for your apps use.
\par Intermediate: MUST be the first WinSock API function called before ANY other and should preferably be ONLY called once!
\par Advanced: It allows an application or DLL to specify the version of Windows Sockets required and to retrieve details of the specific Windows Sockets implementation
\par 
\par WSACleanup
\par 
\par Basics: Tells WinSock API that your app is terminating.
\par 
\par CloseSocket
\par 
\par Basics: This is what the WinSock OCX Close command does, it closes a socket :)
\par 
\par WSAAsyncSelect
\par 
\par Basics: When data is sent to our computer via the network, how do you think WinSock API is gonna notify us that we have this incomming data? Enter WSAAsyncSelect.
\par Intermediate: The WinSock API is basically event driven, similar to the OCX. When data arrive
s for us, the WinSock API needs to notify us of this 'event'. The way it does it is message driven. The same as when a mouse moves over a form, windows sends a mouse move/position message to the form so it knows where the mouse is via x,y co-ords. Windows
 
sends this message to the forms handle (hWnd value). So too, this API call tells WinSock API where we want it to send the messages for our app, this is typically a form. This is a per socket function. So we can tell it that for socket 1, we want to receiv
e
 only incomming connections eg. FD_ACCEPT, or we want it to only receive incomming data, eg. FD_READ, FD_WRITE is a message that WinSock API sends us when the Socket is ready to send data again. FD_CLOSE tells us that the remote computer has closed it's c
onnection.
\par Advanced: This API is a component of our message hooking/SubClassing process to get WinSock API to talk to our app. Once we know where we want to tell WinSock API where to post messages (usually by choosing a form to communicate in and out of to 
the API), we use this to tell WinSock what messages to send for which Socket to what handle (hWnd). eg. We create a socket to listen on. Once all the other API work is done, we use WSAAsyncSelect with our socket name, the form handle it must post messages
 
to, and the message notification types we want to receive, in this case we only need notification of FD_ACCEPT. NB - Once a connection has been accepted on our listening socket, the new one will inherit the parents WSAAsyncSelect values, in this case the 
incomming connection will only receive FD_ACCEPT, but it's a client connection so we need to change this to FD_READ or FD_WRITE or FD_CLOSE, the or is bitwise.
\par 
\par HToNL
\par 
\par Basics: Different Protocols have different ways of representing addresses in bytes. eg an
 IP of 127.0.0.1 = 10011010011011101110010010011001 in binary (dummy values) but the configuration of the bits could be different for different protocols. Host to Network Long sets the bits/bytes for our IP in the right order. Not 100% familiar with this 
API call but it is necessary for proper WinSock API functionality!
\par 
\par HToNS
\par 
\par Basics: Similar to HToNL except for Short (C/C++ data type) / Integer values. Not 100% familiar with this API call but it is necessary for proper WinSock API functionality!
\par 
\par NToHL
\par 
\par Basics: The inverse of HToNL
\par 
\par NToHS
\par \line Basics: The inverse of HToNS
\par 
\par Socket
\par 
\par Basics: Tells WinSock API to give us a free, unused, unassigned, random socket number so we can use it for our purposes.
\par Intermediate: Every call to this function, must be met with a CloseSocket call, even if we don't use the Socket for anything, once we call this we MUST call CloseSocket.
\par 
\par Listen
\par 
\par Basics: The function that tells WinSock API to listen on a specific socket.
\par I
ntermediate: A listening socket will cache a max of 5 incomming connections, I have seen no evidence to support any more than 5. Many things must be taken into account for this to operate properly. eg. we MUST process FD_ACCEPT message ASAP, because anyon
e
 connecting over the 5 limit will be lost. We can however have multiple listening sockets if more than 5 connections are required. Also, any incomming connections inherit our Listening socket's options/properties eg. Send/Receive Buffers, messages eg. FD_
ACCEPT, protocol etc.
\par 
\par Bind
\par 
\par Basics: The irritating and confusing process of Binding a port and network adapter to a socket before initializing Listen is necessary.
\par Intermediate: This is used so that no other apps can use our port and network card.
\par 
\par Accept
\par 
\par Basics: Accepts an incomming connection on a listening Socket.
\par Intermediate: Used after our listening socket received an FD_ACCEPT message.
\par 
\par Recv
\par 
\par Basics: Used to receive incomming data on a socket
\par Intermediate: Used after a socket received a FD_READ message.
\par Advanced: 
\par 
\par Private Declare Function apiGetSockOpt Lib "WSock32" Alias "getsockopt" (ByVal S As Long, ByVal Level As Long, ByVal optname As Long, optval As Any, optlen As Long) As Long
\par Private Declare Function apiSetSockOpt Lib "WSock32" Alias "setsockopt" (ByVal S As Long, ByVal Level As Long, ByVal optname As Long, optval As Any, ByVal optlen As Long) As Long
\par Private Declare Function apiIPToNL Lib "WSock32" Alias "inet_addr" (ByVal cp As String) As Long
\par Private Declare Function apiNLToIP Lib "WSock32" Alias "inet_ntoa" (ByVal inn As Long) As Long
\par Private Declare Function apiConnect Lib "WSock32" Alias "connect" (ByVal S As Long, name As typSocketAddr, ByVal namelen As Long) As Long
\par Private Declare Function apiSend Lib "WSock32" Alias "send" (ByVal S As Long, buf As Any, ByVal buflen As Long, ByVal flags As Long) As Long
\par 
\par Private Declare Function apiCreateWindowEx Lib "User32" Alias "CreateWindowExA" (ByVal dwExStyle As Long, ByVal lp
ClassName As String, ByVal lpWindowName As String, ByVal dwStyle As Long, ByVal x As Long, ByVal y As Long, ByVal nWidth As Long, ByVal nHeight As Long, ByVal hWndParent As Long, ByVal hMenu As Long, ByVal hInstance As Long, lpParam As Any) As Long
\par Private Declare Function apiDestroyWindow Lib "User32" Alias "DestroyWindow" (ByVal hWnd As Long) As Long
\par Private Declare Function apiCallWindowProc Lib "User32" Alias "CallWindowProcA" (ByVal lpPrevWndFunc As Long, ByVal hWnd As Long, ByVal Msg As Long, ByVal wParam As Long, ByVal lParam As Long) As Long
\par Private Declare Function apiSetWindowLong Lib "User32" Alias "SetWindowLongA" (ByVal hWnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
\par 
\par Private Declare Function apiLStrLen Lib "Kernel32" Alias "lstrlenA" (ByVal lpString As Any) As Long
\par Private Declare Function apiLstrCpy Lib "Kernel32" Alias "lstrcpyA" (ByVal lpString1 As String, ByVal lpString2 As Long) As Long
\par Private Declare Sub apiCopyMemory Lib "Kernel32" Alias "RtlMoveMemory" (pDst As Any, pSrc As Any, ByVal ByteLen As Long)
\par 
\par 
\par 
\par 
\par }{\b\f1\ul\insrsid8735674 Credit List}{\f1\fs20\insrsid8735674 
\par 
\par }{\b\f1\fs20\ul\insrsid8735674 Purpose}{\f1\fs20\insrsid8735674 
\par 
\par To list those responsible for this endeavour. This includes a list of my 2 most used examples of OCX conversions.
\par 
\par AllApi.Net
\par 
\par I used an aplication they developed called API-Guide 3.7, which li
sts 925 API functions, their uses, inputs, outputs and gives examples. I also studied a demo program they wrote that shows basic Client/Server functionality. This code seems to have a basis for many of the WinSock API based projects I've seen. I have used
 
many API declarations, constants and ideas from them (so have many other people). Thanks to the AllApi network, much of the foundation was laid for me to begin hard core development on Sox. My WinSockEvent and WinSockError functions are based on their WSA
G
etSelectEvent and WSAGetAsyncError functions for example. However this project was too small for me. They also have a Download file project, but it is too bugy and small to be of much interest. Other projects included Hooking / Unhooking forms, copying me
mory, Pinging, Creating Windows, etc. many ideas/concepts of these appear in my code!
\par 
\par MSDN
\par 
\par I have read EVERY single article on every WinSock OCX AND API command here, most of them I have read over and over again. I read every Error message, what it means,
 what causes it and what can be done to prevent it on MSDN. I have read the ENTIRE API header file, which is what all the constants, types etc. are based on. Unfortunately MSDN doesn't give ANY example code in VB, and the examples of C code are very small
/useless anyway.
\par 
\par HTTPWin (PSC)
\par 
\par A project to download a website or file. Poorly written with old WinSock 1.1 API's eg. WSAIsBlocking (and the guy probably doesn't even know it).
\par 
\par Ronny R. Germany Berlin (PSC) - API Downloading code
\par 
\par His module made by Master Yoda had one thing I used. Otherwise the actual code is terrible
\par 
\par Brian Molidor's 'Tutorial'
\par 
\par Cons: Another example of someone who used the old AllApi.Net modules and forgot to clean up :)
\par Pros: Can't really think of any ... quite a boring project if you ask me
\par 
\par Socks II (PSC) - The first of the real challengers
\par 
\par Cons: Excessive use of Exit Function. Copied an AllApi.Net Module with '96 code in that includes functions for windows 3.x without any modification or cleanup
\par Pros: Fairly well structured (compared to some of the other projects). An example that I began with, so it couldn't have been that bad :) I read his code many times!
\par 
\par 
\par TTOSocket - An ActiveX VB OCX replica of the WinSock OCX
\par 
\par Cons: I don't think this guy is alive anym
ore or something. Creates an instance of the Control for each connection, these are stored in a Collection. Now imagine we have 32,000 of these things ... man the server is gonna DIE! Very confusing to read, I don't know half the time if he's referancing 
a
 variable or function or where the darn thing is, I spend half my time looking to see what he's referancing! I think his WindowProc function needs to be MUCH faster to cope with high demands! Everytime the function is called, it must make a new instance o
f his control even if it isn't gonna use it ... too slow!
\par Pros: A very good effort, lots of hard work obviously went into it, and MANY people contributed to his code! I read this code again and again, there is much to be learned for anyone interested in cre
ating another OCX replacement, or just if you want different ways of doing things! Many ideas came from this code and much credit is due to those responsible for this fine effort! This is THE OCX replacement!
\par 
\par CSocket - My primary competition (But no match I say :))) - Oleg Gdalevich (http://www.vbip.com)
\par 
\par Cons: AGAIN, the excessive use of Collections and use of Exit Function/Sub. I have found a few 'Critical' bugs in this code which I will notify the author about soon! Creates multiple instances of the Cla
ss module to produce an event driven project. Long and irritating variable names !!! I can hardly tell what are variable, functions or API calls!
\par Pros: This code is modified on an ongoing basis, and has many followers. Replicating the OCX command as well a
s could be expected! WELL commented and structured! This code has been an inspiration to me, it has taught me much and deserves as much recognition and appreciation as I could give! It has all in all, helped me more than anything else to grasp the procedu
res necessary for proper WinSock API functionality, And even though I don't agree with his methology, it is the finest effort second only to Sox! This project is the benchmark I test the performance of Sox against (Sox Kicks Ass)
\par 
\par }{\f1\fs20\insrsid7025986\charrsid7025986 John Gala}{\f1\fs20\insrsid7025986 nopoulos}{\f1\fs20\insrsid8735674 
\par }{\f1\fs20\insrsid7025986 
\par Taught me a thing or two about SubClassing}{\f1\fs20\insrsid15615675 ! Because of him, I could understand one of the most essential concepts in Sox design! Thanx John!}{\f1\fs20\insrsid8735674 
\par 
\par }{\f1\fs20\insrsid5975617\charrsid5975617 Manolo Botellero}{\f1\fs20\insrsid5975617 
\par 
\par For sending me an old mod, designed in \rquote 97 for VB 4 that had some very unique constants and data structures I struggled to find and not found in any other project!}{\f1\fs20\insrsid5975617\charrsid5975617 
\par }{\f1\fs20\insrsid8735674 
\par }{\b\f1\ul\insrsid8735674 OLD}{\f1\fs20\insrsid8735674 
\par 
\par 
\par ''Q - Why does Close NOT work as a valid event here ???
\par ''A -It 's used for file Open and Closes ???
\par 'Public Event Closed(Index As Long)
\par 'Public Event Connect(Index As Long)
\par 'Public Event DataArrival(Index As Long, ByVal bytesTotal As Long)
\par 'Public Event ConnectionRequest(Index As Long, ByVal requestID As Long)
\par 'Public Event Error(ByVal Code As Integer, Description As String)
\par ''Public Event Error(Index As Long, ByVal number As Integer, Description As String, ByVal Scode As Long, ByVal Source As String, ByVal HelpFile As String, ByVal HelpContext As Long, CancelDisplay As Boolean)
\par 'Public Event SendComplete(Index As Long)
\par 'Public Event SendProgress(Index As Long, ByVal bytesSent As Long, ByVal bytesRemaining As Long)
\par '
\par 'Public Event Status(Description As String)
\par 
\par 
\par 
\par 
\par 'Other Guys Events
\par 'Public Event ConnectionRequest(ByVal FromListeningSocket As Long)
\par 'Public Event Connected(ByVal SocketID As Long)
\par 'Public Event DataArrival(ByVal SocketID As Long, sData As String)
\par 'Public Event Error(ByVal SocketID As Long, ByVal number As Integer, Description As String)
\par 'Public Event ConnectionsAlert(ByVal SocketID As Long)
\par 'Public Event PeerClosing(ByVal SocketID As Long)
\par 'Public Event SendComplete(ByVal SocketID As Long)
\par 'Public Event StateChanged(ByVal SocketID As Long)
\par 
\par 'Limitation - On initialization of Class modules (through Class_Initialize event), absolutely NO events will be raised
\par             'until Class_Initialize has completely completed, this includes any functions that Class_Initialize calls
\par 'Solution - Allow initialization of Class module through an Initialize function ONLY, it will raise any necessary events of possible fails
\par 'INFO - General Order = Socket -> Bind -> Listen -> Accept ... read the description in Listen call in MSDN for this
\par 
\par 'Limitation - NO events can be fired from the Class Module while processing WindowProc ... events are only fired on complete termination
\par 'Solution - Hardcode what the fired event would do outside the class, by writing a Procedure/Function within the class to handle / simulate the 'event'
\par             'Unfortunately this does not make the Class Module very encapsulated or portable (You may have to change many things if you use it in another project)
\par 'Limitation - The class only supports one connection to a Server, so, we connot make multiple connections to different Servers
\par 'Solution - Create an array of connections to facilitate this ... hint, you could create an Array of type Server.
\par             'I left this out as most apps will only need to support 1 connection to a Server
\par             'and it would complicate things a little more than they already are :)))
\par 
\par 
\par 'API/SOX Advantages
\par 'THE NEED FOR SPEED ...
\par 'Multiple Protocols ... not just TCP & UDP
\par 'Efficiency ... Internal array structure more memory efficient and faster than using an array of WinSock OCX's
\par 'Customizability ... can completely customize it, removing features not needed or adding new features and events
\par 'Enhanced / Customizable Error trapping and messaging ... create your own error messages
\par 'No need to ship/distribute the OCX
\par 'Newer Code ... You can set the version of WinSock you want the client to use / Supports of the latest XP version of WinSock
\par 'Can add data encription directly into the Class before the data get transmitted (Super Easy, could even create random encryption key everytime the server starts)
\par 'If, for example, you will be useing only one type of data eg. Array of bytes, then you can speed up processing by eliminating some variable checks etc.
\par 'Increased speed and efficiency of accepting new connections
\par 'Due to the OCX generating Events, you could skip this step / Optimize the code to automate selected tasks more efficiently
\par 'Foundation to build a WinSock broadcast Server, OCX cannot Broadcast ... or can it ???
\par 'Enhanced data sending on retrieval by perhaps implementing a wait/response on certain data/messages
\par 'No need in app to call frmMain.WinSock1.Bind in other modules due to placing a control on a form, now just call Sox.Bind :)))
\par 'Flexibility - You can either expose the Sox 'events' in a Module, or bring them 'inhouse' for greater encapsulation. Possibly renaming them eg. EventClose, EventDataArrival etc.
\par 'Multiple listening Sockets. Use: One listening socket can cache only 5 incomming connection requests, we may need more. Could allow company users to connect to one socket and they go through
 another Logon procedure as outsiders, could block the one port on a Firewall. Also the outsiders could get different options set. Or use different protocols to listen on different sockets
\par 
\par 'Purpose
\par 'My purpose was not to make a better WinSock OCX ... that's too easy
\par 'The purpose has been 2 fold, for the beginner, to show what API calls relate to which API ones,
\par             'giving them a 'jump start' for their knowledge from the OCX to API usage
\par             'and for the Expert, to give them the foundation to build, customize, improve and enhance their apps using API calls, not the OCX
\par 
\par 'Areas of future improvement
\par 'Listen could have up to 5 incomming connections queued ...
\par 'Listen accepts another call to listen on the same socket (I don't believe you need to bind it first) ... what does this do ???
\par 'Could provide a more robust/dedicated Listen WindowProc here to ONLY accept new sockets
\par 'Seperate WindowProc's, one for Listening for new connections, and another for normal data transfer
\par             'This will also help when accepting new connections as at the moment, I have to set the Listening socket to FD_READ and FD_CLOSE
\par             'this is a problem and could increases messages on the Listening socket, also clients could potentially tell the listening socket to close :(((
\par 'Could add a Portal.DataType, which will store the prefered method of SendData and GetData
\par 
\par 'NB - Although WSAAsyncSelect immediately disables event message posting for the socket in this instance, it is possible that messages could be waiting in the application's message queue.
\par             'Therefore, the application must be prepared to receive network event messages even after cancellation. Closing a socket with closesocket also cancels WSAAsyncSelect message sending,
\par             'but the same caveat about messages in the queue still applies
\par 
\par 'sin_zero(8) as string ... in SocketAddr - Was String * 8 - this ALONE is 16 bytes
\par Private Const INADDR_NONE = &HFFFFFFFF 'Was FFFF (Confirmed) ... Returned address is an error
\par 
\par 
\par Public Function PeekData(Optional d_type As VbVarType = vbArray + vbByte, Optional maxLen As Long = 0) As Variant 'Doesn't remove data from input queue = Possibly used to review the data to check that it is complete ...
\par '    m_lngWindowHandle = CreateWindowEx(0&, "STATIC", "SOCKET_WINDOW", 0&, 0&, 0&, 0&, 0&, 0&, 0&, App.hInstance, ByVal 0&)
\par End Function
\par 
\par 
\par 
\par 
\par 'NB - 'Listen' will only use the information in Bind, if Bind was executed first,
\par             'eg. We set our bound Port and IP, then we call 'Listen' and it will use these details
\par             'Else, if we call 'Listen' then change the Port and IP, we must stop 'Listen'ing and start it again to use the new settings
\par Public Sub Bind(Optional LocalPort As Integer, Optional LocalIP As String)
\par '    Const Procedure As String = "Bind"
\par '    Dim tmpAddress As Long 'Will store our converted IP address, which will be converted into a (Network) Long
\par '    If LocalPort > 0 And LocalPort < 5000 Then Let Server.Port = LocalPort 'Set your valid Port range here ...
\par '    Let tmpAddress = apiNToHL(apiIPToNL(LocalIP)) 'The API could have returned an invalid Long of the IP 255.255.255.255 if it fails eg. there wasn't an IP supplied
\par '    If tmpAddress = INADDR_NONE Then
\par '        If LocalPort > 0 And LocalPort < 5000 Then
\par '            Call RaiseStatus(-1, Procedure, "Invalid Address, Port bound Successfully")
\par '        Else
\par '            Call RaiseStatus(-1, Procedure, "Bind UnSuccessful")
\par '        End If
\par '    Else
\par '        Let Server.Address = tmpAddress 'The API didn't return an invalid IP of 255.255.255.255
\par '        If LocalPort > 0 And LocalPort < 5000 Then
\par '            Call RaiseStatus(-1, Procedure, "Bind Successful")
\par '        Else
\par '            Call RaiseStatus(-1, Procedure, "Invalid Port, Address bound Successfully")
\par '        End If
\par '    End If
\par End Sub
\par 
\par 
\par 
\par 
\par 
\par 
\par 'Unfortunately for us ... since I couldn't get events to be posted from the Class when an FD_ACCEPT message was received,
\par             'we cannot really accept incomming connections outside this Class, so when a message is sent by a client
\par             'to join ... we'll just have to sort him out here :)))
\par Private Function Accept(inSocket As Long) As Long 'Returns: New Sox Number -- inSocket is the listening WinSocket ...
\par }}